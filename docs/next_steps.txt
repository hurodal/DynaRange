PRIORITARIAS
============

1: CONTROL DE EXPOSICIÓN: AVISAR EL USUARIO SI EL RAW QUEDA POR ENCIMA/DEBAJO DEL RANGO DE EXPOSICIÓN NECESARIO PARA EL CÁLCULO SIN EXTRAPOLAR, ESTIMANDO LA CORRECCIÓN EN EV
   Decidir qué subexposicion aplicar a las fotos: -5 EV o otra mayor, fija o dependiente del ISO. O incluso recomendaciones según el modelo de cámara (año de fabricación, etc...)
   Corregir el que la marca de escala "SNR > 0dB" se salga fuera de la grafica (quitarla) en aquellos casos en que queda fuera de la grafica.

        El control de exposición se decide sobre todos solo los umbrales solicitados en el comando --snrthreshold_db, porque los valores de RD que queremos pelotear son todos y solo los solicitados en el comando --snrthreshold_db

        Al final las curvas de S/N deben dibujarse para cada RAW:
        * Desde el min(S/N presente en los datos, min(--snrthreshold_db))
        * Hasta el max(S/N presente en los datos, max(--snrthreshold_db))

        Y sabiendo que las extrapolaciones se pintan en discontinua:
        * Si min(--snrthreshold_db)<min(S/N presente en los datos): discontinua en el tramo desde min(--snrthreshold_db) hasta min(S/N presente en los datos)
        * Si max(--snrthreshold_db)>min(S/N presente en los datos): discontinua en el tramo desde min(S/N presente en los datos) hasta min(--snrthreshold_db)
   

2: FLEXIBILIZAR PARÁMETRO --raw-channels PARA QUE PUEDA OBTENERSE EL AVG DE CUALQUIER COMBINACIÓN DE CANALES, NO SOLO LOS 4 A LA VEZ

3: GRÁFICA DE RD VS ISO + RECTA DE ISO INVARIANZA

4: FALLO PARCHES MONITOR OLED: Mirar qué fallo tan extraño ocurre al leer los parches en las fotos que hice en mi OLED (carpeta "2025-09-13 DynaRange New chart OLED")
   y que os compartí el 10/10 en el chat a las 13:14

5: FALLO CANON 5D II: Corregir el fallo con las fotos de la Canon 5DMkII, que estan giradas 90º debido al sensor de orientación de la cámara.
   Estan en la carpeta "2025-09-12 Carta DynaRange Canon 5dMkII". Introduciendo manualmente las coordenadas que muestro en la captura "target Coords 5DMkII.jpg" no lo pilla bien



NO PRIORITARIAS
===============

6: MODO RENDIMIENTO DEL SENSOR: CURVAS S/N COMPLETAS A PARTIR DE RAWS DE DIFERENTE EXPOSICIÓN

7: IMPLEMENTAR EN EL UI UNA HOMOGRAFÍA (CORRECCIÓN DE PERSPECTIVA) INTERACTIVA CON ASISTENCIA DEL USUARIO (REQUIERE GRÁFICO SENSIBLE AL RATÓN)
   DUDA: LA USAMOS SOLO PARA ESTABLACER VISUALMENTE LAS ESQUINAS DE LA CARTA Y APLICAR LA CORRECCIÓN ACTUAL, O ADEMÁS PARA LEER LOS DATOS SOBRE LA HOMOGRAFÍA SIN NECESIDAD DE APLICAR
   CORRECCIÓN DE PERSPECTIVA

8: ANÁLISIS DE RAWS X-TRANS



HECHOS
======

(HECHO) RENOMBRADO DE ALGUNOS PARÁMETROS (-b -B -s -S -p -P): MINÚSCULA SIEMPRE OPCIÓN MÁS USADA, MAYÚSCULA OPCIÓN SECUNDARIA. RENOMBRAR PARÁMETRO --raw_channels (con s) 

(HECHO) IMPLEMENTAR LA REDEFINICÓN DE --plot --plot-params. JUGAR CON LAS TRANSPARENCIAS EN LA CREACIÓN DE LA CURVA DE S/N 

(HECHO) SIMPLIFICAR PARÁMETRO --snrthreshold-db: -> SUMINISTRAR LISTA DE UMBRALES. CAMBIO ESTRUCTURA DATAFRAME: CAMPO --snrthreshold-db Y ÚNICO CAMPO DE DR (HECHO)

(HECHO) DESCARTE DE LOS ARCHIVOS RAW SUMINISTRADOS COMO BLACK O COMO SATURACION DEL ANÁLISIS: si el usuario suministra alguno de los ficheros requeridos para calcular el nivel de negro y
        saturación, se comprobará si dichos ficheros también han sido suministrados para el análisis de ruido (-i o selección en el GUI), para descartarlos de dicho análisis.

(HECHO) CÁLCULO DE BLACK/SAT SI NO SE SUMINISTRA VALOR NI FICHERO
     BLACK=mínima potencia de 2 con datos en la toma ISO mínimo. P.ej. si el valor RAW más bajo es 900 -> BLACK=1023

     prompt: "write a C++ function that calculates the black level of a sensor as the lowest power of 2 with data in the RAW file mimus 1. E.g. if the lowest value in the RAW data is 900 ->                     BLACK=1023"
        #include <cmath>
        #include <cstdint>
        
        uint32_t calculateBlackLevel(uint32_t minRawValue) {
            // Handle edge cases (e.g., 0 or 1)
            if (minRawValue <= 1) return 0;
        
            // Find next power of 2 greater or equal to minRawValue
            uint32_t power = 1;
            while (power < minRawValue) {
                power <<= 1;  // Equivalent to power *= 2
            }
        
            // Return minus 1 as per requirement
            return power - 1;
        }
        
        Example:
        #include <iostream>
        
        int main() {
            uint32_t lowestValue = 900;
            uint32_t blackLevel = calculateBlackLevel(lowestValue);
            std::cout << "Black level = " << blackLevel << std::endl; // Output: 1023
            return 0;
        }

     SAT=fondo escala bits toma ISO máximo. P.ej. si el valor RAW máximo es 13000 -> SAT=16383

     prompt: "write a C++ function that calculates the saturation level of a sensor as the end of the bit scale of the sensor. E.g. if the max RAW value is 12000 then SAT=16383"

          #include <cstdint>
          #include <cmath>
          
          uint32_t calculateSaturationLevel(uint32_t maxRawValue) {
              if (maxRawValue == 0) return 0;
          
              // Determine the number of bits needed to represent maxRawValue
              uint32_t bitDepth = 0;
              uint32_t temp = maxRawValue;
          
              while (temp > 0) {
                  temp >>= 1;  // Shift right to count bits
                  bitDepth++;
              }
          
              // Saturation level is the maximum value for that bit-depth
              return (1U << bitDepth) - 1;  // e.g. 14 bits -> 2^14 - 1 = 16383
          }
          
          Example:
          #include <iostream>
          
          int main() {
              uint32_t maxValue = 12000;
              uint32_t satLevel = calculateSaturationLevel(maxValue);
              std::cout << "Saturation level = " << satLevel << std::endl;  // Output: 16383
              return 0;
          }









