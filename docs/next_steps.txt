PRIORITARIAS
============

0: REORGANIZACIÓN DE GUI (SUBIDOS rangogui1.png y rangogui2.png A ESTA RUTA)

0: TRATAR DE APLICAR REALTIME EN LAS PESTAÑAS CHART E INPUT CHART -> NO HAY BOTÓN DE PREVIEW
   SUSTITUIR EN AMBAS LA ENTRADA DE NÚMERO DE ROWS/COLS POR SENDOR DESPLEGABLES

0: EN LA PESTAÑA CHART HACEN FALTA 2 CELDAS DE ASPECT RATIO PARA PODER METER LAS DOS PROPORCIONES: 3:2, 4:3, 1:1,...

0a: REVISAR EL PROCESO DE DETECCIÓN DE NIVEL NEGRO/SAT:
    1. Si se suministran ficheros -> BLACK=mean(darkframe), SAT=median(saturation).
    2. Si se suministran valores se usan
    3. En otro caso proceso Automático (explicado abajo)

    IMPORTANTE: PENDIENTE DETECCIÓN DE CÁMARAS CON NIVEL DE NEGRO=0 (Nikon) -> para ellas el nivel de negro=0 y se aplica reconstrucción de la distr. normal

0b: REDUCIR EL UMBRAL DEL CUANTIL EN LA DETECCIÓN DE LOS TESTIGOS, DE THRESHOLD=1-Quantile/4 -> THRESHOLD=1-Quantile/8:
    DIAG=(DIMX^2+DIMY^2)^0.5
    RADIUS=DIAG*0.01  # Radius=1% of the whole Diagonal
    AreaCircle=pi*RADIUS^2
    AreaQuad=(DIMX/2)*(DIMY/2)
    Quantile=AreaCircle/AreaQuad
    # THRESHOLD=1-Quantile/4  # THESHOLD to be used for quantile on corner detection
    THRESHOLD=1-Quantile/8  # THESHOLD to be used for quantile on corner detection

0c: AÑADIR UN CAMPO para indicar qué nombre de cámara aparece como titulo (texto dentro de la imagen) en las graficas (en vez de sacarlo de los EXIF)

1a: AÑADIR al GUI DOS CHECKBOXES (o CAMPOS DE TEXTO DIRECTAMENTE, eso tu sabes mejor) para elegir si se quiere que genere los graficos añadiendo al final del nombre de los archivos
el nombre de camara (que sacaria del campo mencionado en el punto anterior) y el ISO. (si puede ser, con este formato: " - camara tal ISO tal")

1b: CONTROL DE EXPOSICIÓN: AVISAR EL USUARIO SI EL RAW QUEDA POR ENCIMA/DEBAJO DEL RANGO DE EXPOSICIÓN NECESARIO PARA EL CÁLCULO SIN EXTRAPOLAR, ESTIMANDO LA CORRECCIÓN EN EV
   Decidir qué subexposicion aplicar a las fotos: -5 EV o otra mayor, fija o dependiente del ISO. O incluso recomendaciones según el modelo de cámara (año de fabricación, etc...)
   Corregir el que la marca de escala "SNR > 0dB" se salga fuera de la grafica (quitarla) en aquellos casos en que queda fuera de la grafica.

        El control de exposición se decide sobre todos solo los umbrales solicitados en el comando --snrthreshold_db, porque los valores de RD que queremos pelotear son todos y solo los
        solicitados en el comando --snrthreshold_db

        Al final las curvas de S/N deben dibujarse para cada RAW:
        * Desde el min(S/N presente en los datos, min(--snrthreshold_db))
        * Hasta el max(S/N presente en los datos, max(--snrthreshold_db))

        Y sabiendo que las extrapolaciones se pintan en discontinua:
        * Si min(--snrthreshold_db)<min(S/N presente en los datos): discontinua en el tramo desde min(--snrthreshold_db) hasta min(S/N presente en los datos)
        * Si max(--snrthreshold_db)>min(S/N presente en los datos): discontinua en el tramo desde min(S/N presente en los datos) hasta min(--snrthreshold_db)

        Solo sobre los más extremos solicitados. Es decir puedes empezar la comprobación calculando:
        * min/max S/N presente en los datos (IMPORTANTE: solo sobre los valores de S/N supervivientes una vez pasada la selección de --raw-channels, el filtro de -10dB o el que pongamos
         finalmente, y la normalización de Mpx si se pide)
        * min/max --snrthreshold_db (que será el mismo si solo pides un valor)

        Y con esos límites hacer las comparaciones de arriba. Sobre la recomendación de exposición errónea, podemos aproximar al menos de entrada decirle al usuario cuando corresponda,
        una conversión entre exposición y S/N conservadora de 1EV/6dB, es decir:
        * Si A=min(--snrthreshold_db) < B=min(S/N presente en los datos): "Overxposure, reduce exposure by" (B-A)/6 "EV"
        * Si C=max(--snrthreshold_db) > D=max(S/N presente en los datos): "Underexposure, increase exposure by" (C-D)/6 "EV"

2: EN LOS RAW de la NIKON D600 aparece una LINEA BLANCA FINA VERTICAL a la DCHA y ahi se va a buscar las esquinas en automaticamente. No se si esa linea tiene que ver con los pixeles enmascarados
y quizas lo que propone Guillermo de hacer un recorte por los 4 costados lo puede resolver...

3: GRÁFICA DE RD VS ISO + RECTA DE ISO INVARIANZA

4: FALLO PARCHES MONITOR OLED: Mirar qué fallo tan extraño ocurre al leer los parches en las fotos que hice en mi OLED (carpeta "2025-09-13 DynaRange New chart OLED")
   y que os compartí el 10/10 en el chat a las 13:14

5: AÑADIR en el RESULTS.CSV columnas con los valores extraidos de todos los parches, de promedio, desviacion estandar y SNR.
Tambien añadir la posicion en la cuadricula de cada parche. Necesarios para la futura BBDD.


NO PRIORITARIAS
===============

6a: Mirar porque con ISO 102400 la SONY da valores extrañamente muy altos.

8: Cambiar la carpeta donde exportar los ficheros diversos a Mis Imagenes/DynaRange (crearla si no existe).
   Vale, pero sería solo para windows, y tengo que comprobar si Mis Imagenes está reconocida como una carpeta "comodín" en windows, supongo que sí, como lo es "Mis Documentos"

9: MODO RENDIMIENTO DEL SENSOR: CURVAS S/N COMPLETAS A PARTIR DE RAWS DE DIFERENTE EXPOSICIÓN

10: ANÁLISIS DE RAWS X-TRANS



HECHOS
======

(HECHO) MOVER LA COLUMNA 'DR_EV' EN LA PESTAÑA RESULTS JUSTO DESPUES DE LA COLUMNA ISO (SINO QUEDA AL FINAL Y OBLIGA A HACER SCROLL PARA VERLA)

(HECHO, ES MUY AGRESIVO) FILTRO PARA SENSORES CON NIVEL DE NEGRO=0 (NIKON): AÑADIR UN CUARTO FILTRO EN LA RUTINA DE ANALIZAR PARCHES PARA QUE DESCARTE PARCHES CON TODOS LOS VALORES >=0
   Y MÁS DE UN 1% DE PÍXELES A 0 (EXACTAMENTE A 0)

(HECHO) IMPLEMENTAR EN EL UI UNA HOMOGRAFÍA (CORRECCIÓN DE PERSPECTIVA) INTERACTIVA CON ASISTENCIA DEL USUARIO (REQUIERE GRÁFICO SENSIBLE AL RATÓN)
   DUDA: LA USAMOS SOLO PARA ESTABLACER VISUALMENTE LAS ESQUINAS DE LA CARTA Y APLICAR LA CORRECCIÓN ACTUAL, O ADEMÁS PARA LEER LOS DATOS SOBRE LA HOMOGRAFÍA SIN NECESIDAD DE APLICAR
   CORRECCIÓN DE PERSPECTIVA

(HECHO) DESACTIVAR LA ROTACION DEL RAW (va relacionado con el fallo de la 5D MkII)

(HECHO) UTILIZAR EL ARCHIVO RAW MÁS EXPUESTO PERO SIN PÍXELES SATURADOS PARA REALIZAR LA DETECCIÓN DE LAS 4 ESQUINAS. SI TODOS TIENEN PÍXELES SATURADOS TOMAR EL MENOS EXPUESTO
   TAMBIÉN SERÁ ÉSE EL RAW USADO COMO SALIDA PARA EL DEBUG DE PARCHES

(HECHO) RENOMBRADO DE ALGUNOS PARÁMETROS (-b -B -s -S -p -P): MINÚSCULA SIEMPRE OPCIÓN MÁS USADA, MAYÚSCULA OPCIÓN SECUNDARIA. RENOMBRAR PARÁMETRO --raw_channels (con s) 

(HECHO) IMPLEMENTAR LA REDEFINICÓN DE --plot --plot-params. JUGAR CON LAS TRANSPARENCIAS EN LA CREACIÓN DE LA CURVA DE S/N 

(HECHO) SIMPLIFICAR PARÁMETRO --snrthreshold-db: -> SUMINISTRAR LISTA DE UMBRALES. CAMBIO ESTRUCTURA DATAFRAME: CAMPO --snrthreshold-db Y ÚNICO CAMPO DE DR (HECHO)

(HECHO) DESCARTE DE LOS ARCHIVOS RAW SUMINISTRADOS COMO BLACK O COMO SATURACION DEL ANÁLISIS: si el usuario suministra alguno de los ficheros requeridos para calcular el nivel de negro y
        saturación, se comprobará si dichos ficheros también han sido suministrados para el análisis de ruido (-i o selección en el GUI), para descartarlos de dicho análisis.

(HECHO) FLEXIBILIZAR PARÁMETRO --raw-channels PARA QUE PUEDA OBTENERSE EL AVG DE CUALQUIER COMBINACIÓN DE CANALES, NO SOLO LOS 4 A LA VEZ: 0-1 0-1 0-1 0-1 0-2

(HECHO) CÁLCULO DE BLACK/SAT SI NO SE SUMINISTRA VALOR NI FICHERO
     BLACK=mínima potencia de 2 con datos en la toma ISO mínimo. P.ej. si el valor RAW más bajo es 900 -> BLACK=1023

     prompt: "write a C++ function that calculates the black level of a sensor as the lowest power of 2 with data in the RAW file mimus 1. E.g. if the lowest value in the RAW data is 900 ->                     BLACK=1023"
        #include <cmath>
        #include <cstdint>
        
        uint32_t calculateBlackLevel(uint32_t minRawValue) {
            // Handle edge cases (e.g., 0 or 1)
            if (minRawValue <= 1) return 0;
        
            // Find next power of 2 greater or equal to minRawValue
            uint32_t power = 1;
            while (power < minRawValue) {
                power <<= 1;  // Equivalent to power *= 2
            }
        
            // Return minus 1 as per requirement
            return power - 1;
        }
        
        Example:
        #include <iostream>
        
        int main() {
            uint32_t lowestValue = 900;
            uint32_t blackLevel = calculateBlackLevel(lowestValue);
            std::cout << "Black level = " << blackLevel << std::endl; // Output: 1023
            return 0;
        }

     SAT=fondo escala bits toma ISO máximo. P.ej. si el valor RAW máximo es 13000 -> SAT=16383

     prompt: "write a C++ function that calculates the saturation level of a sensor as the end of the bit scale of the sensor. E.g. if the max RAW value is 12000 then SAT=16383"

          #include <cstdint>
          #include <cmath>
          
          uint32_t calculateSaturationLevel(uint32_t maxRawValue) {
              if (maxRawValue == 0) return 0;
          
              // Determine the number of bits needed to represent maxRawValue
              uint32_t bitDepth = 0;
              uint32_t temp = maxRawValue;
          
              while (temp > 0) {
                  temp >>= 1;  // Shift right to count bits
                  bitDepth++;
              }
          
              // Saturation level is the maximum value for that bit-depth
              return (1U << bitDepth) - 1;  // e.g. 14 bits -> 2^14 - 1 = 16383
          }
          
          Example:
          #include <iostream>
          
          int main() {
              uint32_t maxValue = 12000;
              uint32_t satLevel = calculateSaturationLevel(maxValue);
              std::cout << "Saturation level = " << satLevel << std::endl;  // Output: 16383
              return 0;
          }
















