PRIORITARIAS
============

0: REORGANIZACIÓN DE ALGUNOS PARÁMETROS (-b -B -s -S -p -P): MINÚSCULA SIEMPRE OPCIÓN MÁS USADA, MAYÚSCULA OPCIÓN SECUNDARIA. RENOMBRAR PARÁMETRO raw_channels (con s)

1: IMPLEMENTAR LA REDEFINICÓN DE --plot --plot-params. JUGAR CON LAS TRANSPARENCIAS EN LA CREACIÓN DE LA CURVA DE S/N

2: SIMPLIFICAR PARÁMETRO --snrthreshold-db: -> SUMINISTRAR LISTA DE UMBRALES. CAMBIO ESTRUCTURA DATAFRAME: CAMPO --snrthreshold-db Y ÚNICO CAMPO DE DR

3: CONTROL DE EXPOSICIÓN: AVISAR EL USUARIO SI EL RAW QUEDA POR ENCIMA/DEBAJO DEL RANGO DE EXPOSICIÓN NECESARIO PARA EL CÁLCULO SIN EXRAPOLAR, ESTIMANDO LA CORRECCIÓN EN EV

4: DESCARTE DE LOS ARCHIVOS RAW SUMINISTRADOS COMO BLACK O COMO SATURACION DEL ANÁLISIS: si el usuario suministra alguno de los ficheros requeridos para calcular el nivel de negro y saturación, se comprobará si dichos ficheros también han sido suministrados para el análisis de ruido (-i o selección en el GUI), para descartarlos de dicho análisis.

5: GRÁFICA DE RD VS ISO + RECTA DE ISO INVARIANZA



NO PRIORITARIAS
===============

6: CÁLCULO DE BLACK/SAT SI NO SE SUMINISTRA VALOR NI FICHERO
     BLACK=mínima potencia de 2 con datos en la toma ISO mínimo. P.ej. si el valor RAW más bajo es 900 -> BLACK=1023

     prompt: "write a C++ function that calculates the black level of a sensor as the lowest power of 2 with data in the RAW file mimus 1. E.g. if the lowest value in the RAW data is 900 -> BLACK=1023"
        #include <cmath>
        #include <cstdint>
        
        uint32_t calculateBlackLevel(uint32_t minRawValue) {
            // Handle edge cases (e.g., 0 or 1)
            if (minRawValue <= 1) return 0;
        
            // Find next power of 2 greater or equal to minRawValue
            uint32_t power = 1;
            while (power < minRawValue) {
                power <<= 1;  // Equivalent to power *= 2
            }
        
            // Return minus 1 as per requirement
            return power - 1;
        }
        
        Example:
        #include <iostream>
        
        int main() {
            uint32_t lowestValue = 900;
            uint32_t blackLevel = calculateBlackLevel(lowestValue);
            std::cout << "Black level = " << blackLevel << std::endl; // Output: 1023
            return 0;
        }

     SAT=fondo escala bits toma ISO máximo. P.ej. si el valor RAW máximo es 13000 -> SAT=16383

     prompt: "write a C++ function that calculates the saturation level of a sensor as the end of the bit scale of the sensor. E.g. if the max RAW value is 12000 then SAT=16383"

          #include <cstdint>
          #include <cmath>
          
          uint32_t calculateSaturationLevel(uint32_t maxRawValue) {
              if (maxRawValue == 0) return 0;
          
              // Determine the number of bits needed to represent maxRawValue
              uint32_t bitDepth = 0;
              uint32_t temp = maxRawValue;
          
              while (temp > 0) {
                  temp >>= 1;  // Shift right to count bits
                  bitDepth++;
              }
          
              // Saturation level is the maximum value for that bit-depth
              return (1U << bitDepth) - 1;  // e.g. 14 bits -> 2^14 - 1 = 16383
          }
          
          Example:
          #include <iostream>
          
          int main() {
              uint32_t maxValue = 12000;
              uint32_t satLevel = calculateSaturationLevel(maxValue);
              std::cout << "Saturation level = " << satLevel << std::endl;  // Output: 16383
              return 0;
          }


7: MODO RENDIMIENTO DEL SENSOR: CURVAS S/N COMPLETAS A PARTIR DE RAWS DE DIFERENTE EXPOSICIÓN

8: SUSTITUIR CORRECCIÓN DE PERSPECTIVA POR HOMOGRAFÍA CON INTERACCIÓN VISUAL DEL USUARIO (REQUIERE GRÁFICO SENSIBLE AL RATÓN)








