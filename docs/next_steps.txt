PRIORITARIAS
============

0: FILTRO PARA SENSORES CON NIVEL DE NEGRO=0 (NIKON): AÑADIR UN CUARTO FILTRO EN LA RUTINA DE ANALIZAR PARCHES PARA QUE DESCARTE PARCHES CON TODOS LOS VALORES >=0
   Y MÁS DE UN 1% DE PÍXELES A 0 (EXACTAMENTE A 0)

1: VERIFICAR LA ORIENTACION DEL RAW EN LOS METADATOS EXIF (va relacionado con el fallo de la 5D MkII):
PAra evitar problemas con el sensor de orientacion, habria que comprobar el metadato "CameraOrientation" de los EXIF.
Vale, y según la documentación de LibRAW, parece que se puede hacer un:

int LibRaw::open_bayer(unsigned otherflags)

y devuelve:

Bits 2-4 - the orientation of the image (0=do not rotate, 3=180, 5=90CCW, 6=90CW)

Es lo que he podido encontrar aquí: 

https://www.libraw.org/docs/API-CXX.html
Otra opcion es añadir dos botones para girar la imagen 90º a izqda y dcha segun el gusto del usuario...

1C: CONTROL DE EXPOSICIÓN: AVISAR EL USUARIO SI EL RAW QUEDA POR ENCIMA/DEBAJO DEL RANGO DE EXPOSICIÓN NECESARIO PARA EL CÁLCULO SIN EXTRAPOLAR, ESTIMANDO LA CORRECCIÓN EN EV
   Decidir qué subexposicion aplicar a las fotos: -5 EV o otra mayor, fija o dependiente del ISO. O incluso recomendaciones según el modelo de cámara (año de fabricación, etc...)
   Corregir el que la marca de escala "SNR > 0dB" se salga fuera de la grafica (quitarla) en aquellos casos en que queda fuera de la grafica.

        El control de exposición se decide sobre todos solo los umbrales solicitados en el comando --snrthreshold_db, porque los valores de RD que queremos pelotear son todos y solo los
        solicitados en el comando --snrthreshold_db

        Al final las curvas de S/N deben dibujarse para cada RAW:
        * Desde el min(S/N presente en los datos, min(--snrthreshold_db))
        * Hasta el max(S/N presente en los datos, max(--snrthreshold_db))

        Y sabiendo que las extrapolaciones se pintan en discontinua:
        * Si min(--snrthreshold_db)<min(S/N presente en los datos): discontinua en el tramo desde min(--snrthreshold_db) hasta min(S/N presente en los datos)
        * Si max(--snrthreshold_db)>min(S/N presente en los datos): discontinua en el tramo desde min(S/N presente en los datos) hasta min(--snrthreshold_db)

        Solo sobre los más extremos solicitados. Es decir puedes empezar la comprobación calculando:
        * min/max S/N presente en los datos (IMPORTANTE: solo sobre los valores de S/N supervivientes una vez pasada la selección de --raw-channels, el filtro de -10dB o el que pongamos
         finalmente, y la normalización de Mpx si se pide)
        * min/max --snrthreshold_db (que será el mismo si solo pides un valor)

        Y con esos límites hacer las comparaciones de arriba. Sobre la recomendación de exposición errónea, podemos aproximar al menos de entrada decirle al usuario cuando corresponda,
        una conversión entre exposición y S/N conservadora de 1EV/6dB, es decir:
        * Si A=min(--snrthreshold_db) < B=min(S/N presente en los datos): "Overxposure, reduce exposure by" (B-A)/6 "EV"
        * Si C=max(--snrthreshold_db) > D=max(S/N presente en los datos): "Underexposure, increase exposure by" (C-D)/6 "EV"

2: En los RAW de la D600 aparece una linea blanca fina vertical a la dcha y ahi se va a buscar las esquinas en automaticamente. No se si esa linea tiene que ver con los pixeles enmascarados
y quizas lo que propone Guillermo de hacer un recorte por los 4 costados lo puede resolver...

3: GRÁFICA DE RD VS ISO + RECTA DE ISO INVARIANZA

4: FALLO PARCHES MONITOR OLED: Mirar qué fallo tan extraño ocurre al leer los parches en las fotos que hice en mi OLED (carpeta "2025-09-13 DynaRange New chart OLED")
   y que os compartí el 10/10 en el chat a las 13:14

5: FALLO CANON 5D II: Corregir el fallo con las fotos de la Canon 5DMkII, que estan giradas 90º debido al sensor de orientación de la cámara.
   Estan en la carpeta "2025-09-12 Carta DynaRange Canon 5dMkII". Introduciendo manualmente las coordenadas que muestro en la captura "target Coords 5DMkII.jpg" no lo pilla bien



NO PRIORITARIAS
===============

6: MODO RENDIMIENTO DEL SENSOR: CURVAS S/N COMPLETAS A PARTIR DE RAWS DE DIFERENTE EXPOSICIÓN

7: IMPLEMENTAR EN EL UI UNA HOMOGRAFÍA (CORRECCIÓN DE PERSPECTIVA) INTERACTIVA CON ASISTENCIA DEL USUARIO (REQUIERE GRÁFICO SENSIBLE AL RATÓN)
   DUDA: LA USAMOS SOLO PARA ESTABLACER VISUALMENTE LAS ESQUINAS DE LA CARTA Y APLICAR LA CORRECCIÓN ACTUAL, O ADEMÁS PARA LEER LOS DATOS SOBRE LA HOMOGRAFÍA SIN NECESIDAD DE APLICAR
   CORRECCIÓN DE PERSPECTIVA

8: ANÁLISIS DE RAWS X-TRANS



HECHOS
======

(HECHO) UTILIZAR EL ARCHIVO RAW MÁS EXPUESTO PERO SIN PÍXELES SATURADOS PARA REALIZAR LA DETECCIÓN DE LAS 4 ESQUINAS. SI TODOS TIENEN PÍXELES SATURADOS TOMAR EL MENOS EXPUESTO
   TAMBIÉN SERÁ ÉSE EL RAW USADO COMO SALIDA PARA EL DEBUG DE PARCHES

(HECHO) RENOMBRADO DE ALGUNOS PARÁMETROS (-b -B -s -S -p -P): MINÚSCULA SIEMPRE OPCIÓN MÁS USADA, MAYÚSCULA OPCIÓN SECUNDARIA. RENOMBRAR PARÁMETRO --raw_channels (con s) 

(HECHO) IMPLEMENTAR LA REDEFINICÓN DE --plot --plot-params. JUGAR CON LAS TRANSPARENCIAS EN LA CREACIÓN DE LA CURVA DE S/N 

(HECHO) SIMPLIFICAR PARÁMETRO --snrthreshold-db: -> SUMINISTRAR LISTA DE UMBRALES. CAMBIO ESTRUCTURA DATAFRAME: CAMPO --snrthreshold-db Y ÚNICO CAMPO DE DR (HECHO)

(HECHO) DESCARTE DE LOS ARCHIVOS RAW SUMINISTRADOS COMO BLACK O COMO SATURACION DEL ANÁLISIS: si el usuario suministra alguno de los ficheros requeridos para calcular el nivel de negro y
        saturación, se comprobará si dichos ficheros también han sido suministrados para el análisis de ruido (-i o selección en el GUI), para descartarlos de dicho análisis.

(HECHO) FLEXIBILIZAR PARÁMETRO --raw-channels PARA QUE PUEDA OBTENERSE EL AVG DE CUALQUIER COMBINACIÓN DE CANALES, NO SOLO LOS 4 A LA VEZ: 0-1 0-1 0-1 0-1 0-2

(HECHO) CÁLCULO DE BLACK/SAT SI NO SE SUMINISTRA VALOR NI FICHERO
     BLACK=mínima potencia de 2 con datos en la toma ISO mínimo. P.ej. si el valor RAW más bajo es 900 -> BLACK=1023

     prompt: "write a C++ function that calculates the black level of a sensor as the lowest power of 2 with data in the RAW file mimus 1. E.g. if the lowest value in the RAW data is 900 ->                     BLACK=1023"
        #include <cmath>
        #include <cstdint>
        
        uint32_t calculateBlackLevel(uint32_t minRawValue) {
            // Handle edge cases (e.g., 0 or 1)
            if (minRawValue <= 1) return 0;
        
            // Find next power of 2 greater or equal to minRawValue
            uint32_t power = 1;
            while (power < minRawValue) {
                power <<= 1;  // Equivalent to power *= 2
            }
        
            // Return minus 1 as per requirement
            return power - 1;
        }
        
        Example:
        #include <iostream>
        
        int main() {
            uint32_t lowestValue = 900;
            uint32_t blackLevel = calculateBlackLevel(lowestValue);
            std::cout << "Black level = " << blackLevel << std::endl; // Output: 1023
            return 0;
        }

     SAT=fondo escala bits toma ISO máximo. P.ej. si el valor RAW máximo es 13000 -> SAT=16383

     prompt: "write a C++ function that calculates the saturation level of a sensor as the end of the bit scale of the sensor. E.g. if the max RAW value is 12000 then SAT=16383"

          #include <cstdint>
          #include <cmath>
          
          uint32_t calculateSaturationLevel(uint32_t maxRawValue) {
              if (maxRawValue == 0) return 0;
          
              // Determine the number of bits needed to represent maxRawValue
              uint32_t bitDepth = 0;
              uint32_t temp = maxRawValue;
          
              while (temp > 0) {
                  temp >>= 1;  // Shift right to count bits
                  bitDepth++;
              }
          
              // Saturation level is the maximum value for that bit-depth
              return (1U << bitDepth) - 1;  // e.g. 14 bits -> 2^14 - 1 = 16383
          }
          
          Example:
          #include <iostream>
          
          int main() {
              uint32_t maxValue = 12000;
              uint32_t satLevel = calculateSaturationLevel(maxValue);
              std::cout << "Saturation level = " << satLevel << std::endl;  // Output: 16383
              return 0;
          }











