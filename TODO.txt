Varios comentarios:

TODO 1: CÁLCULO DE BLACK/SAT DESDE FICHEROS RAW -> (HECHO)
    
    Entiendo que de momento solo funciona con valores black/sat pasados por el usuario.
Faltaría añadir la posibilidad de obtenerlos de fichero RAW. Para black sería la media de todos
los píxeles del RAW darkframe. Para sat el cuantil 5% (o incluso 1%) del RAW saturado obtenido
con la función simplona que te pasé. 

        He simplificado la función del cálculo del percentil 5% parametrizándola
         (perc=0.5 es la mediana de toda la vida, perc=0.05 es el percentil 5%, etc...):

        cppFunction('
                    double quantilecpp(Rcpp::NumericVector xx, double perc) {
                    Rcpp::NumericVector x = Rcpp::clone(xx);
                    std::size_t n = x.size() * perc;
                    std::nth_element(x.begin(), x.begin() + n, x.end());
                    return x[n]; 
                    }
                    ')

        set.seed(10)
        x=rnorm(24000000)  # sensor de 24Mpx

        median1=quantile(x, probs=0.05) |> as.numeric()
        median2=quantilecpp(x, 0.05)


TODO 2: DISEÑO CARTA MAGENTA -> magentachart.R
    
    La corrección geométrica está hard coded para las tomas de la Olympus de Hugo. 
Aquí tendremos que hablar sobre un diseño de carta que incluya guías para detectar sus 4 esquinas.
Creo que con 4 círculos blancos + detección del valor máximo en la zona bastará.
No hemos hablado de la carta, si usamos la de Bill Claff o nos inventamos una.
Sea como sea la carta de Bill Claff no tiene testigos en las 4 esquinas para poder
corregir los errores del usuario en la toma y hacer la corrección geométrica. 

He creado una rutina (la he subido a main) para crear la carta de colores. Podemos poner tantos parches como queramos pero en principio he replicado los 11x7 de Bill, con dos mejoras:
* El magenta es más próximo a la alineación de canales RAW (o debería, ya lo veremos)
* He reducido los saltos de color en los parches oscuros y aumentado en los claros, para tener un mejor reparto de muestras
Por otro lado he añadido 4 testigos blancos centrados donde caerían las esquinas de una fila más de parches por cada lado. Tras hacer la foto estas bolitas se desenfocarán y será fácil localizar su centro (será el nivel RAW máximo), con lo cual ya tendremos las 4 coordenadas para automatizar la corrección geométrica imprescindible para ser inmunes a que el usuario no centre bien las fotos.
Las 4 bolitas deberían buscarse en el canal G del RAW menos expuesto (ISO base) para que ningún parche se pueda confundir con ellas. Escribiré una rutina que busque esos centros.

Ver si es factible la parametrización:
--chart -c <gamma R G B> : Create a test chart in PNG format ranging colours from (0,0,0) to (R,G,B) with gamma
gamma es un float (por defecto gamma=1/1.4) y RGB son enteros en el rango 0..255


TODO 3: CURVAS DE APROXIMACIÓN vs INTERPOLACIÓN (HECHO)

(Los splines son de verdad, mejor usar *ajuste por mínimos cuadrados* "least-squares fit" )

    Tus splines son splines de verdad? es decir, pasan por los puntos calculados o los aproximan?
Lo comento porque aunque mi código R las llama splines, que son curvas de interpolación, 
en realidad lo que acabo usando son curvas de aproximación, es decir curvas que no pasan exactamente
por los puntos sino que los aproximan suavemente. 
Esto es importante para que las desviaciones de las medidas no introduzcan error.

Opciones que evalúo actualmente:

1. Usar TODOS los puntos obtenidos de la curva de S/N y aplicar un ajuste polinómico de mínimos cuadrados de orden 2 o 3 -> AJUSTE ÓPTIMO CURVA DE ORDEN 3, SOLUCIÓN DEFINITIVA
2. Filtrar quedándonos solo con los puntos con S/N en la vecindad del umbral usado (12dB, 0dB,...) y aplicar un ajuste polinómico de orden 2 o incluso lineal -> NO HACE FALTA NI PROBARLO
P.ej. para calcular el RD con el criterio 12dB, solo se usarán parches con S/N entre 12-5 = 7dB y 12+5 = 17dB
En parches_desechar_calculo_polinomios.png se explica la forma de desechar parches. Este método es el más robusto pero plantea la imposibilidad de pintar una curva global que ajuste bien todos los puntos


TODO 4: ORDENACIÓN FICHEROS RAW POR EXPOSICIÓN -> (HECHO)

    Sobre los ficheros RAW suministrados por el usuario, en realidad no necesitamos ni saber
 el ISO de cada uno ni obligar al usuario a renombrarlos u ordenarlos. 
 Con sus niveles RAW medios ya los podemos ordenar de menos a más exposición 
 (lo que equivale de menos a más ISO). Sería bueno que en la salida aparezcan ordenados 
 (salvo casos raros, los propios nombres de los RAW ya deberían implicar una ordenación, 
 pero igual un usuario empezó por el ISO mayor o repitió tomas)
 El RAW MENOS expuesto será el usado para localizar los 4 extremos de la carta


TODO 5: INTERNACIONALIZACIÓN -> (HECHO) Pendiente actualizar nuevas cadenas.

    i18n -> Internacionalización -> Que el programa se pueda usar en varios idiomas disponibles.


TODO 6: NORMALIZACIÓN A CUALQUIER RESOLUCIÓN PEDIDA (POR DEFECTO 8Mpx)

   Código para normalización del RD para cierta cantidad de Mpx, que sería la usable para
comparar cámaras de forma justa. El cálculo a nivel de píxel actual es injusto para las cámaras
con muchos Mpx. Te pasaré la formula, es sencilla.

La corrección se hace sobre los valores obtenidos de SNR, ANTES de ajustarlos a curvas, según la fórmula:

SNRnorm dB = SNRpor píxel dB + 20 * log10[(Mpx / 12,7)^(1/2)]


TODO 7: CÁLCULO ESQUINAS CARTA MAGENTA PARA CORRECCIÓN GEOMÉTRICA -> (HECHO)

    Código para cálculo esquinas carta (max del canal G del RAW en cada cuadrante): detect4corners.R
    Divide la imagen en 4 cuadrantes (se asume que en cada uno habrá uno y solo un círculo) y en cada uno
    se toman los 0,05% píxeles más brillantes -> se calcula la mediana de sus posiciones X e Y

    Problema: es preciso detectar la localización del canal G del RAW, normalmente RG/GB pero a veces GB/RG. Opciones:
      1. Leer metadatos con LibRAW
      2. Buscar el canal más expuesto, pero cerca de las esquinas (testigos)


TODO 8: VALORES DE BLACK/SAT POR DEFECTO: APROXIMACIÓN DESDE LAS CAPTURAS DE LA CARTA A ISO BASE

    Código para obtención valores por defecto BLACK y SAT si el usuario no los aporta 
    BLACK=mínima potencia de 2 con datos en la toma ISO mínimo. P.ej. si el valor RAW más bajo es 900 -> BLACK=1023
    SAT=fondo escala bits toma ISO máximo. P.ej. si el valor RAW máximo es 13000 -> SAT=16383


TODO 9: PARAMETRIZAR LOS PÍXELES DE SEGURIDAD EN CADA PARCHE

    Con un valor relativo: patch-ratio=0.5 -> solo el recorte central de alto y ancho la mitad del parche se usa

TODO 10: USAR LOS 4 CANALES RAW

   Ejecutar el procesado 4 veces uno para cada canal:
    imgBayer=img[row(img)%%2 & col(img)%%2]  # R
    imgBayer=img[row(img)%%2 & !col(img)%%2]  # G1
    imgBayer=img[!row(img)%%2 & col(img)%%2]  # G2
    imgBayer=img[!row(img)%%2 & !col(img)%%2]  # B

    Los puntos proporcionados por cada canal son 100% compatibles entre sí, así que pueden aproximarse polinómicamente todos juntos


TODO 11: pequeñas correcciones en el GUI:

    - Al clicar para cargar los dark y sat frame, el titulo de la ventana deberia ser "Select a dark frame" y no "select file",
    porque cuando la abres a veces no recuerdas en cual clicaste y tienes que andar cerrando y probando de nuevo
    - (HECHO) Estaria muy bien poder hacer drag&drop con los ficheros.
    - Al crear las graficas, que pregunte en que carpeta te las deja o bien que se puede indicar (idealmente via las preferencias
    cuando tengamos la GUI mas avanzada) . Por defecto, creo que seria mejor en Imagenes/DynaRange en vez de en Mis documentos sin mas..


TODO 12: añadir la obtencion del metadato de ISO del RAW. Esto es lo que me dice la IA:

C++

#include <libraw/libraw.h>
#include <iostream>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        std::cerr << "Uso: " << argv[0] << " <archivo_raw>" << std::endl;
        return 1;
    }

    LibRaw rawProcessor;
    int ret = rawProcessor.open_file(argv[1]);

    if (ret != LIBRAW_SUCCESS) {
        std::cerr << "Error al abrir el archivo: " << libraw_strerror(ret) << std::endl;
        return 1;
    }

    ret = rawProcessor.unpack();

    if (ret != LIBRAW_SUCCESS) {
        std::cerr << "Error al descodificar el archivo: " << libraw_strerror(ret) << std::endl;
        return 1;
    }

    // Acceder al valor de ISO
    float iso_speed = rawProcessor.imgdata.other.iso_speed;

    std::cout << "El valor de ISO es: " << iso_speed << std::endl;

    rawProcessor.recycle();

    return 0;
}

En este ejemplo, la clave está en rawProcessor.imgdata.other.iso_speed.
La librería organiza la información en la estructura libraw_processed_image_t y sus subestructuras,
donde imgdata es un miembro de la clase LibRaw y other es una sub-estructura que contiene datos misceláneos, como la velocidad ISO.


TODO 13: estudiar bien cómo lidiar bien con la falta de datos/Normalización del umbral inferior (-10dB)
         Decidir si antes la falta de datos se EXTRAPOLA o se emite un aviso de insuficiencia de datos (se puede incluso sugerir la sobreexposición/subexposición requerida)


TODO 14: Creación/Uso de carta con número de parches MxN parametrizables.


TODO 15: Posibilidad de meterle coordenadas y número de parches MxN ad-hoc para usar cualquier carta rectangular
